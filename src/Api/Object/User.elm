-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.Object.User exposing (AnyPinnableItemsOptionalArguments, AvatarUrlOptionalArguments, CommitCommentsOptionalArguments, ContributionsCollectionOptionalArguments, FollowersOptionalArguments, FollowingOptionalArguments, GistCommentsOptionalArguments, GistRequiredArguments, GistsOptionalArguments, HovercardOptionalArguments, IssueCommentsOptionalArguments, IssuesOptionalArguments, OrganizationRequiredArguments, OrganizationsOptionalArguments, PinnableItemsOptionalArguments, PinnedItemsOptionalArguments, PinnedRepositoriesOptionalArguments, ProjectRequiredArguments, ProjectsOptionalArguments, PublicKeysOptionalArguments, PullRequestsOptionalArguments, RegistryPackagesForQueryOptionalArguments, RegistryPackagesOptionalArguments, RepositoriesContributedToOptionalArguments, RepositoriesOptionalArguments, RepositoryRequiredArguments, SavedRepliesOptionalArguments, SponsorshipsAsMaintainerOptionalArguments, SponsorshipsAsSponsorOptionalArguments, StarredRepositoriesOptionalArguments, TopRepositoriesOptionalArguments, TopRepositoriesRequiredArguments, WatchingOptionalArguments, anyPinnableItems, avatarUrl, bio, bioHTML, commitComments, company, companyHTML, contributionsCollection, createdAt, databaseId, email, followers, following, gist, gistComments, gists, hovercard, id, isBountyHunter, isCampusExpert, isDeveloperProgramMember, isEmployee, isHireable, isSiteAdmin, isViewer, issueComments, issues, itemShowcase, location, login, name, organization, organizations, pinnableItems, pinnedItems, pinnedItemsRemaining, pinnedRepositories, project, projects, projectsResourcePath, projectsUrl, publicKeys, pullRequests, registryPackages, registryPackagesForQuery, repositories, repositoriesContributedTo, repository, resourcePath, savedReplies, sponsorsListing, sponsorshipsAsMaintainer, sponsorshipsAsSponsor, starredRepositories, status, topRepositories, updatedAt, url, viewerCanChangePinnedItems, viewerCanCreateProjects, viewerCanFollow, viewerIsFollowing, watching, websiteUrl)

import Api.Enum.GistPrivacy
import Api.Enum.IssueState
import Api.Enum.PinnableItemType
import Api.Enum.ProjectState
import Api.Enum.PullRequestState
import Api.Enum.RegistryPackageType
import Api.Enum.RepositoryAffiliation
import Api.Enum.RepositoryContributionType
import Api.Enum.RepositoryPrivacy
import Api.InputObject
import Api.Interface
import Api.Object
import Api.Scalar
import Api.ScalarCodecs
import Api.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


type alias AnyPinnableItemsOptionalArguments =
    { type_ : OptionalArgument Api.Enum.PinnableItemType.PinnableItemType }


{-| Determine if this repository owner has any items that can be pinned to their profile.

  - type\_ - Filter to only a particular kind of pinnable item.

-}
anyPinnableItems : (AnyPinnableItemsOptionalArguments -> AnyPinnableItemsOptionalArguments) -> SelectionSet Bool Api.Object.User
anyPinnableItems fillInOptionals =
    let
        filledInOptionals =
            fillInOptionals { type_ = Absent }

        optionalArgs =
            [ Argument.optional "type" filledInOptionals.type_ (Encode.enum Api.Enum.PinnableItemType.toString) ]
                |> List.filterMap identity
    in
    Object.selectionForField "Bool" "anyPinnableItems" optionalArgs Decode.bool


type alias AvatarUrlOptionalArguments =
    { size : OptionalArgument Int }


{-| A URL pointing to the user's public avatar.

  - size - The size of the resulting square image.

-}
avatarUrl : (AvatarUrlOptionalArguments -> AvatarUrlOptionalArguments) -> SelectionSet Api.ScalarCodecs.Uri Api.Object.User
avatarUrl fillInOptionals =
    let
        filledInOptionals =
            fillInOptionals { size = Absent }

        optionalArgs =
            [ Argument.optional "size" filledInOptionals.size Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForField "ScalarCodecs.Uri" "avatarUrl" optionalArgs (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapCodecs |> .codecUri |> .decoder)


{-| The user's public profile bio.
-}
bio : SelectionSet (Maybe String) Api.Object.User
bio =
    Object.selectionForField "(Maybe String)" "bio" [] (Decode.string |> Decode.nullable)


{-| The user's public profile bio as HTML.
-}
bioHTML : SelectionSet Api.ScalarCodecs.Html Api.Object.User
bioHTML =
    Object.selectionForField "ScalarCodecs.Html" "bioHTML" [] (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapCodecs |> .codecHtml |> .decoder)


type alias CommitCommentsOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of commit comments made by this user.

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
commitComments : (CommitCommentsOptionalArguments -> CommitCommentsOptionalArguments) -> SelectionSet decodesTo Api.Object.CommitCommentConnection -> SelectionSet decodesTo Api.Object.User
commitComments fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "commitComments" optionalArgs object_ identity


{-| The user's public profile company.
-}
company : SelectionSet (Maybe String) Api.Object.User
company =
    Object.selectionForField "(Maybe String)" "company" [] (Decode.string |> Decode.nullable)


{-| The user's public profile company as HTML.
-}
companyHTML : SelectionSet Api.ScalarCodecs.Html Api.Object.User
companyHTML =
    Object.selectionForField "ScalarCodecs.Html" "companyHTML" [] (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapCodecs |> .codecHtml |> .decoder)


type alias ContributionsCollectionOptionalArguments =
    { organizationID : OptionalArgument Api.ScalarCodecs.Id
    , from : OptionalArgument Api.ScalarCodecs.DateTime
    , to : OptionalArgument Api.ScalarCodecs.DateTime
    }


{-| The collection of contributions this user has made to different repositories.

  - organizationID - The ID of the organization used to filter contributions.
  - from - Only contributions made at this time or later will be counted. If omitted, defaults to a year ago.
  - to - Only contributions made before and up to and including this time will be counted. If omitted, defaults to the current time.

-}
contributionsCollection : (ContributionsCollectionOptionalArguments -> ContributionsCollectionOptionalArguments) -> SelectionSet decodesTo Api.Object.ContributionsCollection -> SelectionSet decodesTo Api.Object.User
contributionsCollection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { organizationID = Absent, from = Absent, to = Absent }

        optionalArgs =
            [ Argument.optional "organizationID" filledInOptionals.organizationID (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "from" filledInOptionals.from (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDateTime), Argument.optional "to" filledInOptionals.to (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDateTime) ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "contributionsCollection" optionalArgs object_ identity


{-| Identifies the date and time when the object was created.
-}
createdAt : SelectionSet Api.ScalarCodecs.DateTime Api.Object.User
createdAt =
    Object.selectionForField "ScalarCodecs.DateTime" "createdAt" [] (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapCodecs |> .codecDateTime |> .decoder)


{-| Identifies the primary key from the database.
-}
databaseId : SelectionSet (Maybe Int) Api.Object.User
databaseId =
    Object.selectionForField "(Maybe Int)" "databaseId" [] (Decode.int |> Decode.nullable)


{-| The user's publicly visible profile email.
-}
email : SelectionSet String Api.Object.User
email =
    Object.selectionForField "String" "email" [] Decode.string


type alias FollowersOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of users the given user is followed by.

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
followers : (FollowersOptionalArguments -> FollowersOptionalArguments) -> SelectionSet decodesTo Api.Object.FollowerConnection -> SelectionSet decodesTo Api.Object.User
followers fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "followers" optionalArgs object_ identity


type alias FollowingOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of users the given user is following.

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
following : (FollowingOptionalArguments -> FollowingOptionalArguments) -> SelectionSet decodesTo Api.Object.FollowingConnection -> SelectionSet decodesTo Api.Object.User
following fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "following" optionalArgs object_ identity


type alias GistRequiredArguments =
    { name : String }


{-| Find gist by repo name.

  - name - The gist name to find.

-}
gist : GistRequiredArguments -> SelectionSet decodesTo Api.Object.Gist -> SelectionSet (Maybe decodesTo) Api.Object.User
gist requiredArgs object_ =
    Object.selectionForCompositeField "gist" [ Argument.required "name" requiredArgs.name Encode.string ] object_ (identity >> Decode.nullable)


type alias GistCommentsOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of gist comments made by this user.

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
gistComments : (GistCommentsOptionalArguments -> GistCommentsOptionalArguments) -> SelectionSet decodesTo Api.Object.GistCommentConnection -> SelectionSet decodesTo Api.Object.User
gistComments fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "gistComments" optionalArgs object_ identity


type alias GistsOptionalArguments =
    { privacy : OptionalArgument Api.Enum.GistPrivacy.GistPrivacy
    , orderBy : OptionalArgument Api.InputObject.GistOrder
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of the Gists the user has created.

  - privacy - Filters Gists according to privacy.
  - orderBy - Ordering options for gists returned from the connection
  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
gists : (GistsOptionalArguments -> GistsOptionalArguments) -> SelectionSet decodesTo Api.Object.GistConnection -> SelectionSet decodesTo Api.Object.User
gists fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { privacy = Absent, orderBy = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "privacy" filledInOptionals.privacy (Encode.enum Api.Enum.GistPrivacy.toString), Argument.optional "orderBy" filledInOptionals.orderBy Api.InputObject.encodeGistOrder, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "gists" optionalArgs object_ identity


type alias HovercardOptionalArguments =
    { primarySubjectId : OptionalArgument Api.ScalarCodecs.Id }


{-| The hovercard information for this user in a given context

  - primarySubjectId - The ID of the subject to get the hovercard in the context of

-}
hovercard : (HovercardOptionalArguments -> HovercardOptionalArguments) -> SelectionSet decodesTo Api.Object.Hovercard -> SelectionSet decodesTo Api.Object.User
hovercard fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { primarySubjectId = Absent }

        optionalArgs =
            [ Argument.optional "primarySubjectId" filledInOptionals.primarySubjectId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "hovercard" optionalArgs object_ identity


id : SelectionSet Api.ScalarCodecs.Id Api.Object.User
id =
    Object.selectionForField "ScalarCodecs.Id" "id" [] (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapCodecs |> .codecId |> .decoder)


{-| Whether or not this user is a participant in the GitHub Security Bug Bounty.
-}
isBountyHunter : SelectionSet Bool Api.Object.User
isBountyHunter =
    Object.selectionForField "Bool" "isBountyHunter" [] Decode.bool


{-| Whether or not this user is a participant in the GitHub Campus Experts Program.
-}
isCampusExpert : SelectionSet Bool Api.Object.User
isCampusExpert =
    Object.selectionForField "Bool" "isCampusExpert" [] Decode.bool


{-| Whether or not this user is a GitHub Developer Program member.
-}
isDeveloperProgramMember : SelectionSet Bool Api.Object.User
isDeveloperProgramMember =
    Object.selectionForField "Bool" "isDeveloperProgramMember" [] Decode.bool


{-| Whether or not this user is a GitHub employee.
-}
isEmployee : SelectionSet Bool Api.Object.User
isEmployee =
    Object.selectionForField "Bool" "isEmployee" [] Decode.bool


{-| Whether or not the user has marked themselves as for hire.
-}
isHireable : SelectionSet Bool Api.Object.User
isHireable =
    Object.selectionForField "Bool" "isHireable" [] Decode.bool


{-| Whether or not this user is a site administrator.
-}
isSiteAdmin : SelectionSet Bool Api.Object.User
isSiteAdmin =
    Object.selectionForField "Bool" "isSiteAdmin" [] Decode.bool


{-| Whether or not this user is the viewing user.
-}
isViewer : SelectionSet Bool Api.Object.User
isViewer =
    Object.selectionForField "Bool" "isViewer" [] Decode.bool


type alias IssueCommentsOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of issue comments made by this user.

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
issueComments : (IssueCommentsOptionalArguments -> IssueCommentsOptionalArguments) -> SelectionSet decodesTo Api.Object.IssueCommentConnection -> SelectionSet decodesTo Api.Object.User
issueComments fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "issueComments" optionalArgs object_ identity


type alias IssuesOptionalArguments =
    { orderBy : OptionalArgument Api.InputObject.IssueOrder
    , labels : OptionalArgument (List String)
    , states : OptionalArgument (List Api.Enum.IssueState.IssueState)
    , filterBy : OptionalArgument Api.InputObject.IssueFilters
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of issues associated with this user.

  - orderBy - Ordering options for issues returned from the connection.
  - labels - A list of label names to filter the pull requests by.
  - states - A list of states to filter the issues by.
  - filterBy - Filtering options for issues returned from the connection.
  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
issues : (IssuesOptionalArguments -> IssuesOptionalArguments) -> SelectionSet decodesTo Api.Object.IssueConnection -> SelectionSet decodesTo Api.Object.User
issues fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { orderBy = Absent, labels = Absent, states = Absent, filterBy = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "orderBy" filledInOptionals.orderBy Api.InputObject.encodeIssueOrder, Argument.optional "labels" filledInOptionals.labels (Encode.string |> Encode.list), Argument.optional "states" filledInOptionals.states (Encode.enum Api.Enum.IssueState.toString |> Encode.list), Argument.optional "filterBy" filledInOptionals.filterBy Api.InputObject.encodeIssueFilters, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "issues" optionalArgs object_ identity


{-| Showcases a selection of repositories and gists that the profile owner has either curated or that have been selected automatically based on popularity.
-}
itemShowcase : SelectionSet decodesTo Api.Object.ProfileItemShowcase -> SelectionSet decodesTo Api.Object.User
itemShowcase object_ =
    Object.selectionForCompositeField "itemShowcase" [] object_ identity


{-| The user's public profile location.
-}
location : SelectionSet (Maybe String) Api.Object.User
location =
    Object.selectionForField "(Maybe String)" "location" [] (Decode.string |> Decode.nullable)


{-| The username used to login.
-}
login : SelectionSet String Api.Object.User
login =
    Object.selectionForField "String" "login" [] Decode.string


{-| The user's public profile name.
-}
name : SelectionSet (Maybe String) Api.Object.User
name =
    Object.selectionForField "(Maybe String)" "name" [] (Decode.string |> Decode.nullable)


type alias OrganizationRequiredArguments =
    { login : String }


{-| Find an organization by its login that the user belongs to.

  - login - The login of the organization to find.

-}
organization : OrganizationRequiredArguments -> SelectionSet decodesTo Api.Object.Organization -> SelectionSet (Maybe decodesTo) Api.Object.User
organization requiredArgs object_ =
    Object.selectionForCompositeField "organization" [ Argument.required "login" requiredArgs.login Encode.string ] object_ (identity >> Decode.nullable)


type alias OrganizationsOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of organizations the user belongs to.

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
organizations : (OrganizationsOptionalArguments -> OrganizationsOptionalArguments) -> SelectionSet decodesTo Api.Object.OrganizationConnection -> SelectionSet decodesTo Api.Object.User
organizations fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "organizations" optionalArgs object_ identity


type alias PinnableItemsOptionalArguments =
    { types : OptionalArgument (List Api.Enum.PinnableItemType.PinnableItemType)
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of repositories and gists this profile owner can pin to their profile.

  - types - Filter the types of pinnable items that are returned.
  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
pinnableItems : (PinnableItemsOptionalArguments -> PinnableItemsOptionalArguments) -> SelectionSet decodesTo Api.Object.PinnableItemConnection -> SelectionSet decodesTo Api.Object.User
pinnableItems fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { types = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "types" filledInOptionals.types (Encode.enum Api.Enum.PinnableItemType.toString |> Encode.list), Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pinnableItems" optionalArgs object_ identity


type alias PinnedItemsOptionalArguments =
    { types : OptionalArgument (List Api.Enum.PinnableItemType.PinnableItemType)
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of repositories and gists this profile owner has pinned to their profile

  - types - Filter the types of pinned items that are returned.
  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
pinnedItems : (PinnedItemsOptionalArguments -> PinnedItemsOptionalArguments) -> SelectionSet decodesTo Api.Object.PinnableItemConnection -> SelectionSet decodesTo Api.Object.User
pinnedItems fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { types = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "types" filledInOptionals.types (Encode.enum Api.Enum.PinnableItemType.toString |> Encode.list), Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pinnedItems" optionalArgs object_ identity


{-| Returns how many more items this profile owner can pin to their profile.
-}
pinnedItemsRemaining : SelectionSet Int Api.Object.User
pinnedItemsRemaining =
    Object.selectionForField "Int" "pinnedItemsRemaining" [] Decode.int


type alias PinnedRepositoriesOptionalArguments =
    { privacy : OptionalArgument Api.Enum.RepositoryPrivacy.RepositoryPrivacy
    , orderBy : OptionalArgument Api.InputObject.RepositoryOrder
    , affiliations : OptionalArgument (List (Maybe Api.Enum.RepositoryAffiliation.RepositoryAffiliation))
    , ownerAffiliations : OptionalArgument (List (Maybe Api.Enum.RepositoryAffiliation.RepositoryAffiliation))
    , isLocked : OptionalArgument Bool
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of repositories this user has pinned to their profile

  - privacy - If non-null, filters repositories according to privacy
  - orderBy - Ordering options for repositories returned from the connection
  - affiliations - Array of viewer's affiliation options for repositories returned from the connection. For example, OWNER will include only repositories that the current viewer owns.
  - ownerAffiliations - Array of owner's affiliation options for repositories returned from the connection. For example, OWNER will include only repositories that the organization or user being viewed owns.
  - isLocked - If non-null, filters repositories according to whether they have been locked
  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
pinnedRepositories : (PinnedRepositoriesOptionalArguments -> PinnedRepositoriesOptionalArguments) -> SelectionSet decodesTo Api.Object.RepositoryConnection -> SelectionSet decodesTo Api.Object.User
pinnedRepositories fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { privacy = Absent, orderBy = Absent, affiliations = Absent, ownerAffiliations = Absent, isLocked = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "privacy" filledInOptionals.privacy (Encode.enum Api.Enum.RepositoryPrivacy.toString), Argument.optional "orderBy" filledInOptionals.orderBy Api.InputObject.encodeRepositoryOrder, Argument.optional "affiliations" filledInOptionals.affiliations (Encode.enum Api.Enum.RepositoryAffiliation.toString |> Encode.maybe |> Encode.list), Argument.optional "ownerAffiliations" filledInOptionals.ownerAffiliations (Encode.enum Api.Enum.RepositoryAffiliation.toString |> Encode.maybe |> Encode.list), Argument.optional "isLocked" filledInOptionals.isLocked Encode.bool, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pinnedRepositories" optionalArgs object_ identity


type alias ProjectRequiredArguments =
    { number : Int }


{-| Find project by number.

  - number - The project number to find.

-}
project : ProjectRequiredArguments -> SelectionSet decodesTo Api.Object.Project -> SelectionSet (Maybe decodesTo) Api.Object.User
project requiredArgs object_ =
    Object.selectionForCompositeField "project" [ Argument.required "number" requiredArgs.number Encode.int ] object_ (identity >> Decode.nullable)


type alias ProjectsOptionalArguments =
    { orderBy : OptionalArgument Api.InputObject.ProjectOrder
    , search : OptionalArgument String
    , states : OptionalArgument (List Api.Enum.ProjectState.ProjectState)
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of projects under the owner.

  - orderBy - Ordering options for projects returned from the connection
  - search - Query to search projects by, currently only searching by name.
  - states - A list of states to filter the projects by.
  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
projects : (ProjectsOptionalArguments -> ProjectsOptionalArguments) -> SelectionSet decodesTo Api.Object.ProjectConnection -> SelectionSet decodesTo Api.Object.User
projects fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { orderBy = Absent, search = Absent, states = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "orderBy" filledInOptionals.orderBy Api.InputObject.encodeProjectOrder, Argument.optional "search" filledInOptionals.search Encode.string, Argument.optional "states" filledInOptionals.states (Encode.enum Api.Enum.ProjectState.toString |> Encode.list), Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "projects" optionalArgs object_ identity


{-| The HTTP path listing user's projects
-}
projectsResourcePath : SelectionSet Api.ScalarCodecs.Uri Api.Object.User
projectsResourcePath =
    Object.selectionForField "ScalarCodecs.Uri" "projectsResourcePath" [] (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapCodecs |> .codecUri |> .decoder)


{-| The HTTP URL listing user's projects
-}
projectsUrl : SelectionSet Api.ScalarCodecs.Uri Api.Object.User
projectsUrl =
    Object.selectionForField "ScalarCodecs.Uri" "projectsUrl" [] (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapCodecs |> .codecUri |> .decoder)


type alias PublicKeysOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of public keys associated with this user.

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
publicKeys : (PublicKeysOptionalArguments -> PublicKeysOptionalArguments) -> SelectionSet decodesTo Api.Object.PublicKeyConnection -> SelectionSet decodesTo Api.Object.User
publicKeys fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "publicKeys" optionalArgs object_ identity


type alias PullRequestsOptionalArguments =
    { states : OptionalArgument (List Api.Enum.PullRequestState.PullRequestState)
    , labels : OptionalArgument (List String)
    , headRefName : OptionalArgument String
    , baseRefName : OptionalArgument String
    , orderBy : OptionalArgument Api.InputObject.IssueOrder
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of pull requests associated with this user.

  - states - A list of states to filter the pull requests by.
  - labels - A list of label names to filter the pull requests by.
  - headRefName - The head ref name to filter the pull requests by.
  - baseRefName - The base ref name to filter the pull requests by.
  - orderBy - Ordering options for pull requests returned from the connection.
  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
pullRequests : (PullRequestsOptionalArguments -> PullRequestsOptionalArguments) -> SelectionSet decodesTo Api.Object.PullRequestConnection -> SelectionSet decodesTo Api.Object.User
pullRequests fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { states = Absent, labels = Absent, headRefName = Absent, baseRefName = Absent, orderBy = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "states" filledInOptionals.states (Encode.enum Api.Enum.PullRequestState.toString |> Encode.list), Argument.optional "labels" filledInOptionals.labels (Encode.string |> Encode.list), Argument.optional "headRefName" filledInOptionals.headRefName Encode.string, Argument.optional "baseRefName" filledInOptionals.baseRefName Encode.string, Argument.optional "orderBy" filledInOptionals.orderBy Api.InputObject.encodeIssueOrder, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pullRequests" optionalArgs object_ identity


type alias RegistryPackagesOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    , name : OptionalArgument String
    , names : OptionalArgument (List (Maybe String))
    , repositoryId : OptionalArgument Api.ScalarCodecs.Id
    , packageType : OptionalArgument Api.Enum.RegistryPackageType.RegistryPackageType
    , registryPackageType : OptionalArgument String
    , publicOnly : OptionalArgument Bool
    }


{-| A list of registry packages under the owner.

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.
  - name - Find registry package by name.
  - names - Find registry packages by their names.
  - repositoryId - Find registry packages in a repository.
  - packageType - Filter registry package by type.
  - registryPackageType - Filter registry package by type (string).
  - publicOnly - Filter registry package by whether it is publicly visible

-}
registryPackages : (RegistryPackagesOptionalArguments -> RegistryPackagesOptionalArguments) -> SelectionSet decodesTo Api.Object.RegistryPackageConnection -> SelectionSet decodesTo Api.Object.User
registryPackages fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, before = Absent, first = Absent, last = Absent, name = Absent, names = Absent, repositoryId = Absent, packageType = Absent, registryPackageType = Absent, publicOnly = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "name" filledInOptionals.name Encode.string, Argument.optional "names" filledInOptionals.names (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "repositoryId" filledInOptionals.repositoryId (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId), Argument.optional "packageType" filledInOptionals.packageType (Encode.enum Api.Enum.RegistryPackageType.toString), Argument.optional "registryPackageType" filledInOptionals.registryPackageType Encode.string, Argument.optional "publicOnly" filledInOptionals.publicOnly Encode.bool ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "registryPackages" optionalArgs object_ identity


type alias RegistryPackagesForQueryOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    , query : OptionalArgument String
    , packageType : OptionalArgument Api.Enum.RegistryPackageType.RegistryPackageType
    }


{-| A list of registry packages for a particular search query.

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.
  - query - Find registry package by search query.
  - packageType - Filter registry package by type.

-}
registryPackagesForQuery : (RegistryPackagesForQueryOptionalArguments -> RegistryPackagesForQueryOptionalArguments) -> SelectionSet decodesTo Api.Object.RegistryPackageConnection -> SelectionSet decodesTo Api.Object.User
registryPackagesForQuery fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, before = Absent, first = Absent, last = Absent, query = Absent, packageType = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "query" filledInOptionals.query Encode.string, Argument.optional "packageType" filledInOptionals.packageType (Encode.enum Api.Enum.RegistryPackageType.toString) ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "registryPackagesForQuery" optionalArgs object_ identity


type alias RepositoriesOptionalArguments =
    { privacy : OptionalArgument Api.Enum.RepositoryPrivacy.RepositoryPrivacy
    , orderBy : OptionalArgument Api.InputObject.RepositoryOrder
    , affiliations : OptionalArgument (List (Maybe Api.Enum.RepositoryAffiliation.RepositoryAffiliation))
    , ownerAffiliations : OptionalArgument (List (Maybe Api.Enum.RepositoryAffiliation.RepositoryAffiliation))
    , isLocked : OptionalArgument Bool
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    , isFork : OptionalArgument Bool
    }


{-| A list of repositories that the user owns.

  - privacy - If non-null, filters repositories according to privacy
  - orderBy - Ordering options for repositories returned from the connection
  - affiliations - Array of viewer's affiliation options for repositories returned from the connection. For example, OWNER will include only repositories that the current viewer owns.
  - ownerAffiliations - Array of owner's affiliation options for repositories returned from the connection. For example, OWNER will include only repositories that the organization or user being viewed owns.
  - isLocked - If non-null, filters repositories according to whether they have been locked
  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.
  - isFork - If non-null, filters repositories according to whether they are forks of another repository

-}
repositories : (RepositoriesOptionalArguments -> RepositoriesOptionalArguments) -> SelectionSet decodesTo Api.Object.RepositoryConnection -> SelectionSet decodesTo Api.Object.User
repositories fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { privacy = Absent, orderBy = Absent, affiliations = Absent, ownerAffiliations = Absent, isLocked = Absent, after = Absent, before = Absent, first = Absent, last = Absent, isFork = Absent }

        optionalArgs =
            [ Argument.optional "privacy" filledInOptionals.privacy (Encode.enum Api.Enum.RepositoryPrivacy.toString), Argument.optional "orderBy" filledInOptionals.orderBy Api.InputObject.encodeRepositoryOrder, Argument.optional "affiliations" filledInOptionals.affiliations (Encode.enum Api.Enum.RepositoryAffiliation.toString |> Encode.maybe |> Encode.list), Argument.optional "ownerAffiliations" filledInOptionals.ownerAffiliations (Encode.enum Api.Enum.RepositoryAffiliation.toString |> Encode.maybe |> Encode.list), Argument.optional "isLocked" filledInOptionals.isLocked Encode.bool, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "isFork" filledInOptionals.isFork Encode.bool ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "repositories" optionalArgs object_ identity


type alias RepositoriesContributedToOptionalArguments =
    { privacy : OptionalArgument Api.Enum.RepositoryPrivacy.RepositoryPrivacy
    , orderBy : OptionalArgument Api.InputObject.RepositoryOrder
    , isLocked : OptionalArgument Bool
    , includeUserRepositories : OptionalArgument Bool
    , contributionTypes : OptionalArgument (List (Maybe Api.Enum.RepositoryContributionType.RepositoryContributionType))
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of repositories that the user recently contributed to.

  - privacy - If non-null, filters repositories according to privacy
  - orderBy - Ordering options for repositories returned from the connection
  - isLocked - If non-null, filters repositories according to whether they have been locked
  - includeUserRepositories - If true, include user repositories
  - contributionTypes - If non-null, include only the specified types of contributions. The GitHub.com UI uses [COMMIT, ISSUE, PULL_REQUEST, REPOSITORY]
  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
repositoriesContributedTo : (RepositoriesContributedToOptionalArguments -> RepositoriesContributedToOptionalArguments) -> SelectionSet decodesTo Api.Object.RepositoryConnection -> SelectionSet decodesTo Api.Object.User
repositoriesContributedTo fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { privacy = Absent, orderBy = Absent, isLocked = Absent, includeUserRepositories = Absent, contributionTypes = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "privacy" filledInOptionals.privacy (Encode.enum Api.Enum.RepositoryPrivacy.toString), Argument.optional "orderBy" filledInOptionals.orderBy Api.InputObject.encodeRepositoryOrder, Argument.optional "isLocked" filledInOptionals.isLocked Encode.bool, Argument.optional "includeUserRepositories" filledInOptionals.includeUserRepositories Encode.bool, Argument.optional "contributionTypes" filledInOptionals.contributionTypes (Encode.enum Api.Enum.RepositoryContributionType.toString |> Encode.maybe |> Encode.list), Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "repositoriesContributedTo" optionalArgs object_ identity


type alias RepositoryRequiredArguments =
    { name : String }


{-| Find Repository.

  - name - Name of Repository to find.

-}
repository : RepositoryRequiredArguments -> SelectionSet decodesTo Api.Object.Repository -> SelectionSet (Maybe decodesTo) Api.Object.User
repository requiredArgs object_ =
    Object.selectionForCompositeField "repository" [ Argument.required "name" requiredArgs.name Encode.string ] object_ (identity >> Decode.nullable)


{-| The HTTP path for this user
-}
resourcePath : SelectionSet Api.ScalarCodecs.Uri Api.Object.User
resourcePath =
    Object.selectionForField "ScalarCodecs.Uri" "resourcePath" [] (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapCodecs |> .codecUri |> .decoder)


type alias SavedRepliesOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    , orderBy : OptionalArgument Api.InputObject.SavedReplyOrder
    }


{-| Replies this user has saved

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.
  - orderBy - The field to order saved replies by.

-}
savedReplies : (SavedRepliesOptionalArguments -> SavedRepliesOptionalArguments) -> SelectionSet decodesTo Api.Object.SavedReplyConnection -> SelectionSet (Maybe decodesTo) Api.Object.User
savedReplies fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, before = Absent, first = Absent, last = Absent, orderBy = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy Api.InputObject.encodeSavedReplyOrder ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "savedReplies" optionalArgs object_ (identity >> Decode.nullable)


{-| The GitHub Sponsors listing for this user.
-}
sponsorsListing : SelectionSet decodesTo Api.Object.SponsorsListing -> SelectionSet (Maybe decodesTo) Api.Object.User
sponsorsListing object_ =
    Object.selectionForCompositeField "sponsorsListing" [] object_ (identity >> Decode.nullable)


type alias SponsorshipsAsMaintainerOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    , includePrivate : OptionalArgument Bool
    , orderBy : OptionalArgument Api.InputObject.SponsorshipOrder
    }


{-| This object's sponsorships as the maintainer.

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.
  - includePrivate - Whether or not to include private sponsorships in the result set
  - orderBy - Ordering options for sponsorships returned from this connection. If left blank, the sponsorships will be ordered based on relevancy to the viewer.

-}
sponsorshipsAsMaintainer : (SponsorshipsAsMaintainerOptionalArguments -> SponsorshipsAsMaintainerOptionalArguments) -> SelectionSet decodesTo Api.Object.SponsorshipConnection -> SelectionSet decodesTo Api.Object.User
sponsorshipsAsMaintainer fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, before = Absent, first = Absent, last = Absent, includePrivate = Absent, orderBy = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "includePrivate" filledInOptionals.includePrivate Encode.bool, Argument.optional "orderBy" filledInOptionals.orderBy Api.InputObject.encodeSponsorshipOrder ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "sponsorshipsAsMaintainer" optionalArgs object_ identity


type alias SponsorshipsAsSponsorOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    , orderBy : OptionalArgument Api.InputObject.SponsorshipOrder
    }


{-| This object's sponsorships as the sponsor.

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.
  - orderBy - Ordering options for sponsorships returned from this connection. If left blank, the sponsorships will be ordered based on relevancy to the viewer.

-}
sponsorshipsAsSponsor : (SponsorshipsAsSponsorOptionalArguments -> SponsorshipsAsSponsorOptionalArguments) -> SelectionSet decodesTo Api.Object.SponsorshipConnection -> SelectionSet decodesTo Api.Object.User
sponsorshipsAsSponsor fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, before = Absent, first = Absent, last = Absent, orderBy = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "orderBy" filledInOptionals.orderBy Api.InputObject.encodeSponsorshipOrder ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "sponsorshipsAsSponsor" optionalArgs object_ identity


type alias StarredRepositoriesOptionalArguments =
    { ownedByViewer : OptionalArgument Bool
    , orderBy : OptionalArgument Api.InputObject.StarOrder
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| Repositories the user has starred.

  - ownedByViewer - Filters starred repositories to only return repositories owned by the viewer.
  - orderBy - Order for connection
  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
starredRepositories : (StarredRepositoriesOptionalArguments -> StarredRepositoriesOptionalArguments) -> SelectionSet decodesTo Api.Object.StarredRepositoryConnection -> SelectionSet decodesTo Api.Object.User
starredRepositories fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { ownedByViewer = Absent, orderBy = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "ownedByViewer" filledInOptionals.ownedByViewer Encode.bool, Argument.optional "orderBy" filledInOptionals.orderBy Api.InputObject.encodeStarOrder, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "starredRepositories" optionalArgs object_ identity


{-| The user's description of what they're currently doing.
-}
status : SelectionSet decodesTo Api.Object.UserStatus -> SelectionSet (Maybe decodesTo) Api.Object.User
status object_ =
    Object.selectionForCompositeField "status" [] object_ (identity >> Decode.nullable)


type alias TopRepositoriesOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    , since : OptionalArgument Api.ScalarCodecs.DateTime
    }


type alias TopRepositoriesRequiredArguments =
    { orderBy : Api.InputObject.RepositoryOrder }


{-| Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.
  - orderBy - Ordering options for repositories returned from the connection
  - since - How far back in time to fetch contributed repositories

-}
topRepositories : (TopRepositoriesOptionalArguments -> TopRepositoriesOptionalArguments) -> TopRepositoriesRequiredArguments -> SelectionSet decodesTo Api.Object.RepositoryConnection -> SelectionSet decodesTo Api.Object.User
topRepositories fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, before = Absent, first = Absent, last = Absent, since = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int, Argument.optional "since" filledInOptionals.since (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDateTime) ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "topRepositories" (optionalArgs ++ [ Argument.required "orderBy" requiredArgs.orderBy Api.InputObject.encodeRepositoryOrder ]) object_ identity


{-| Identifies the date and time when the object was last updated.
-}
updatedAt : SelectionSet Api.ScalarCodecs.DateTime Api.Object.User
updatedAt =
    Object.selectionForField "ScalarCodecs.DateTime" "updatedAt" [] (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapCodecs |> .codecDateTime |> .decoder)


{-| The HTTP URL for this user
-}
url : SelectionSet Api.ScalarCodecs.Uri Api.Object.User
url =
    Object.selectionForField "ScalarCodecs.Uri" "url" [] (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapCodecs |> .codecUri |> .decoder)


{-| Can the viewer pin repositories and gists to the profile?
-}
viewerCanChangePinnedItems : SelectionSet Bool Api.Object.User
viewerCanChangePinnedItems =
    Object.selectionForField "Bool" "viewerCanChangePinnedItems" [] Decode.bool


{-| Can the current viewer create new projects on this owner.
-}
viewerCanCreateProjects : SelectionSet Bool Api.Object.User
viewerCanCreateProjects =
    Object.selectionForField "Bool" "viewerCanCreateProjects" [] Decode.bool


{-| Whether or not the viewer is able to follow the user.
-}
viewerCanFollow : SelectionSet Bool Api.Object.User
viewerCanFollow =
    Object.selectionForField "Bool" "viewerCanFollow" [] Decode.bool


{-| Whether or not this user is followed by the viewer.
-}
viewerIsFollowing : SelectionSet Bool Api.Object.User
viewerIsFollowing =
    Object.selectionForField "Bool" "viewerIsFollowing" [] Decode.bool


type alias WatchingOptionalArguments =
    { privacy : OptionalArgument Api.Enum.RepositoryPrivacy.RepositoryPrivacy
    , orderBy : OptionalArgument Api.InputObject.RepositoryOrder
    , affiliations : OptionalArgument (List (Maybe Api.Enum.RepositoryAffiliation.RepositoryAffiliation))
    , ownerAffiliations : OptionalArgument (List (Maybe Api.Enum.RepositoryAffiliation.RepositoryAffiliation))
    , isLocked : OptionalArgument Bool
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| A list of repositories the given user is watching.

  - privacy - If non-null, filters repositories according to privacy
  - orderBy - Ordering options for repositories returned from the connection
  - affiliations - Affiliation options for repositories returned from the connection
  - ownerAffiliations - Array of owner's affiliation options for repositories returned from the connection. For example, OWNER will include only repositories that the organization or user being viewed owns.
  - isLocked - If non-null, filters repositories according to whether they have been locked
  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
watching : (WatchingOptionalArguments -> WatchingOptionalArguments) -> SelectionSet decodesTo Api.Object.RepositoryConnection -> SelectionSet decodesTo Api.Object.User
watching fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { privacy = Absent, orderBy = Absent, affiliations = Absent, ownerAffiliations = Absent, isLocked = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "privacy" filledInOptionals.privacy (Encode.enum Api.Enum.RepositoryPrivacy.toString), Argument.optional "orderBy" filledInOptionals.orderBy Api.InputObject.encodeRepositoryOrder, Argument.optional "affiliations" filledInOptionals.affiliations (Encode.enum Api.Enum.RepositoryAffiliation.toString |> Encode.maybe |> Encode.list), Argument.optional "ownerAffiliations" filledInOptionals.ownerAffiliations (Encode.enum Api.Enum.RepositoryAffiliation.toString |> Encode.maybe |> Encode.list), Argument.optional "isLocked" filledInOptionals.isLocked Encode.bool, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "watching" optionalArgs object_ identity


{-| A URL pointing to the user's public website/blog.
-}
websiteUrl : SelectionSet (Maybe Api.ScalarCodecs.Uri) Api.Object.User
websiteUrl =
    Object.selectionForField "(Maybe ScalarCodecs.Uri)" "websiteUrl" [] (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapCodecs |> .codecUri |> .decoder |> Decode.nullable)
